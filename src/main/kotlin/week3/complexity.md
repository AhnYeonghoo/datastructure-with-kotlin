# Complexity
- 시간 복잡도
  - 시간 효율이 안 좋은 알고리즘은 데이터 양이 많아짐에 따라 비용이 크게 증가
- 공간 복잡도
  - space complexity는 알고리즘이 사용하는 메모리
- 두 복잡도는 사실 두마리 토끼 같은 존재, 적절한 균형이 중요하다.

# Big O 표기법
- 상한선을 표기 (알고리즘 효율의 최악의 case를 표기함)
- [참고] Small o는 보다 엄격한 기준으로 표기
- 외에도 Big Omega는 하한선, Big Theta는 상-하한선 사이를 표기

# 시간복잡도
- 상수시간
    - 데이터 양에 관계없이 동일한 실행시간 O(1)

- 선형시간
  - 데이터 양이 증가함에 따라 실행시간도 선형 비례 증가 O(n) -> n은 데이터 개수
  - O(2n + 3) -> O(n)이라고 표기한다.

- 제곱시간
  - 데이터 양이 증가함에 따라 실행시간도 제곱(n squared) 비례 증가

- 로그시간
  - 데이터 중에 일부만 access/read 하는 로그 복잡도
  - O(log N)

- 준선형시간
  - O(N log N)
  - 선형시간보다는 안 좋지만, 제곱에 비해서는 좋음.

- Polynomial, Exponential, Factorial Time, Etc.......

- 결론: 시간복잡도가 알고리즘의 절대적인 실행속도를 의미하는 것은 아니다.
- 데이터 양이 많아짐에 따른 알고리즘의 임의 계산 횟수임.(데이터를 받고 읽고..)
- 또한, 머신 스펙에 따라 제곱복잡도가 준선형복잡도보다 빠르게 실행될 수도 있다.
- 시간복잡도를 더 나은 속도로 개선할 수 있도록 생각을 하고 코드를 짜자!


# 공간복잡도
- 공간복잡도 관점에서도 프로그램을 볼 수 있다.
- 하지만, 앞서 말했듯 두 복잡도는 두마리 토끼와 같은 존재.
- 공간복잡도와 시간복잡도간의 적절한 균형이 중요.


# Array
- 순서가 있는 컬렉션

# Linked List
- 링크드리스트를 이루는 각 개체를 Node라고 부른다.
- Node가 순서대로 나열된 형태라고 볼 수 있음. 